#include "include.h"
#include "common.cpp"
#include "read.cpp"

using namespace std;

double err = 15.0/100;

int overlap(Read r1, Read r2, int **dist_buf) {
    int n = r1.len;
    int m = r2.len;
    cout<<n<<" "<<m<<endl;
    for(int i=0; i<=n; i++) {
        dist_buf[0][i] = 0;
    }
    for(int i=0; i<=m; i++) {
        dist_buf[i][0] = i;
    }

    for(int i=1; i<=m ; i++) {
        for(int j=1; j<=n; j++) {
            if(r2.read[i-1] == r1.read[j-1]){
                dist_buf[i][j] = dist_buf[i-1][j-1];
            } else {
                dist_buf[i][j] = min(dist_buf[i-1][j], dist_buf[i][j-1]) + 1;
            }
        }
    }

    int ans = 0;
    int min_error = max(m, n);
    int error = 3*m/20;
    for(int i=0; i<=n; i++) {
        if(dist_buf[m][i] < error && dist_buf[m][i] < min_error) {
            ans = i;
            min_error = dist_buf[m][i];
        }
    }
    cout<<endl<<endl;
    for(int i=m; i>0 ; i--) {
        if(dist_buf[i][n] < err*i && dist_buf[i][n] < min_error) {
            ans = i;
            min_error = dist_buf[i][n];
        }
    }
    cout<<ans<<endl;
    return ans;
}

int main() {
    /* read all reads */
	vector<Read> readList;
	//readReads("../data/ecoli_1K/ecoli.reads.1k.readsim.30x.fasta", readList);

    char x1[10000];
	char *y1 = "TTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGCTTCTGAACTGATTACCTGCCGTGAGTAAATTAAAATTTTATTGACTTAGGCACTAAATACTTTAACCAATATAGGCATAGCGCACAGACAGATAAAAATTACAGAGTACACAACATCCATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGACGCGTACAGGAAACACAGAAAAAAGCCCGCACCTGACAGTGCGGGCTTTTTTTTTCGACCAAAGGTAACGAGGTAACAACCATGCGAGTGTTGAAGTTCGGCGGTACATCAGTGGCAAATGCAGAACGTTCTCTGCGTGTTGCCGATATTCTGGAAAGCAATGCCAGCAGGGGCAGGTGGCCACCGTCCTCTCTGCCCCCGCCAAAATCACCAACCACCTGGTGGCGATGATTGAAAAAACCATTAGCGGCCAGGATGCTTTACCCAATATCAGCGATGCCGAACGTATTTTTGCCGAACTTTTGACGGGACTCGCCGCCGCCCAGCCGGGGTTCCCGCCGGCGCAATTGAAAACTTTCGTCGATCAGGAATTTGCCCAAATAAAACATGTCCTGCATGGC";
	int z1 = strlen(y1);
	strcpy(x1, y1);
	Read r1(x1, z1);
	char x2[10000];
	char *y2 = "TTCATTCTGACTGCAACGGGCAACTATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGAGCTTCTGAACTGGTTACATGCCGTGAGTAAATTAAAATTTTATTGACTTAGGTCACTAAATACTATTAACCAATATAGGCATAGCGCACAGACAGATAAAAATTACAGAGTACACAACATCCATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGACGCGTACAGGAAACACAGAAAAAAGCCCGCACCTGACAGTGCGGCTTTTTTTTTCGACCAAAGGTTAACGAGGTAACAACCATGCGAGTGTTGAAGTTCGGCGGTACTCAGTGGCAAATGCAGAACGTTTTCTGCGTCGTTGCCGATATTCTGGAAAGCAATGCCAGGCAGGGGCAGGTGGCCACCGTCCTCTCTGCCCCCGCCAAAATCACCAACCACCTGGTGGCGATGATTGAAAAAACCATTAGCGGCCAGGATGCTTTACCCAATATCAGCGATGCCGAACGTATTTTTGCCGAACTTTTGACGGGACTCGCCGCCGCCCAGCCGGGGTTCCCGCTGGCGCAATTGAAAACTTTCGTCGATCAGGAATTTGCCCAAATAAAACATGTCCTGCATGGCATTAGTTTGTTGGGGCAGTGCCCGGATAGCATCAACGCTGCGCTGATTTGCCGTGGCGAGAAAATGTCGATGCCATTATGGCCGGCGTATTAGAAGCGCGCGGTCACAACGTTACTGTTGTCGATCCGGTCGAAAAACTGCTGGCAGTGCGGCATTACCTCGAATCTACCGTCGATATTGCTGAGTCCACCCGCCGTATTGCGGCAAGCCGCATTCCGGCTGACCACATGGTGCTGATGGCAGGTTTCACCGCCGGTAATGAAAAAGGCGAAACTGGTGGTGCTTGGACGCAACGGTTCCGACTACTCTGCTGCGGTGCTGGCTGCCTGTTTACGCGCCGATTGTTGCGAGATTTGGACGGACGTTGACGGGGTCTATACCTGCGACCCGCGTCAGGTGCCCGATGGAGGTTGTTGAAGTCGATGTCCTACCAGGAAGCGATGGAGCTTTCCTACTTCGGCGCTAAAGTTCTTCACCCCCGCACCATTACCCCCATCGCCCAGTTCCAGATCCCTTGCCTGATTAAAAATACCGGAAATCCTCAAGCACCAGGTACGCTCATTGGTGCCAGCCGTGATGAAGACGAATTACCGGTCAAGGGCATGTTCCAATCTGAATAACATGGCAATGTTCAGCGTTTCTGGTCCGGGGATGAAAGGGATGGTCGGCATGGCGGCGCGCGTCTTTGGCAGCGATGTCACGCGCCCGTATTTCCGTGGTGCTGATTACGCAATCATCTTCCGAATACAGCATCAGTTTCTGCGTTCCACAAAGCGACTGTGTTGCGAGCTGAACGGGCAATGCAGGAAGAGTTCTACCTGGAACTGAAAGAAGGCTTACTGGAGCCGCTGGCAGTGACGGAACGGCTGGCCATTATCTCGGTGGTAGGTGATGGTATGCGCACCTTGCGTGGGATCTCTGGCCGAAATTCTTTGCCCACTGGCCCGCGCCAATATCAACATTGTCGCCATTGCTCAGGGATCTTCTGAACGCTCAATCTCTGTCGTGGTAAATAACGATGATGCGACCACTGGCGTGCGCGTTACTCATCAGATGCTGTTCAATACCGATCAGGTTATCGAAGTGTTTGTGATTGGCGTCGGTGGCGTTGGCGGTGCGCTGCTGGAGCAACTGGAAGCGTCAGCAAAGCTGGCTGAAGAATAAACATATCGACTTACGTGTCTGCGGTGTTGCCAACTCGAAGGCTCTGCTCACCAATGTACATGGCCTTAATCTGGAAAACTGGCAGGAAGAACTGGCGCAAGCCAAAGAGCCGTTTAATCTCGGGCGCTTAATTCGCCTCGTGAAAGAATATCATCTGCTGAACCCGGTCATTGTAGACTGCACTTCCAGCCAGGCAGTGGCGGATCAATATGCCGA";
	int z2 = strlen(y2);
	strcpy(x2, y2);
	Read r2(x2, z2);
	readList.push_back(r1);
	readList.push_back(r2);

	// for every pair of Reads calculate the overlap 
	int sz = readList.size();
    int len = 0;
    for(int i=0; i<sz; i++) {
        if(readList[i].len > len) {
            len = readList[i].len;
        }
    }

	int **mat = allocate2d(sz, sz);
    //cout<<len<<endl;
	int **distBuf = allocate2d(len + 1, len +1);
	for(int i=0; i<sz; i++) {
		for(int j=i+1; j<sz; j++) {
			mat[i][j] = overlap(readList[i], readList[j], distBuf);
            cout<<"dist "<<mat[i][j]<<endl;
		}
	}

    return 0;
}

